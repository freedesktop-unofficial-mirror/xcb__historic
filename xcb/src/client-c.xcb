dnl Copyright (C) 2001-2003 Bart Massey and Jamey Sharp.
dnl All Rights Reserved.  See the file COPYING in this directory
dnl for licensing information.
dnl
include(`generics.xcb')dnl
divert(-1) dnl Discard any text until a divert(0).

dnl -- Implementations of macros specified in global macros.m4

dnl ENUM(type name, name list)
define(`ENUM', `pushdef(`ENUMNAME', `$1')TYPEDEF(`enum $1 {
ENUMLOOP(shift($@))dnl
}', `$1')popdef(`ENUMNAME')')
define(`ENUMLOOP', `ifelse($1, , , `    ENUMNAME`$1',
ENUMLOOP(shift($@))')')

dnl PAD(bytes)
define(`PAD', `FIELD(`CARD8', `pad'PADQTY`'ifelse($1, 1, , `[$1]'))
define(`PADQTY', eval(1+PADQTY))
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Declares a field of the given type with the given name.
dnl FIELD(type, name)
define(`FIELD', `PUSHDIV(STRUCTDIV)dnl
    `$1' `$2';
POPDIV()define(`FIELDQTY', eval(1+FIELDQTY))')

dnl Declares a field with the given name which is a pointer to the given type.
dnl POINTERFIELD(type, name)
define(`POINTERFIELD', `PUSHDIV(STRUCTDIV)dnl
    `$1' *`$2';
POPDIV()define(`FIELDQTY', eval(1+FIELDQTY))')


dnl -- Language-specific macros

dnl Use C-style comments.
changecom(`/*', `*/')

dnl COMMENT(text)
define(`COMMENT', `/* '`$@'` */')


dnl Exactly one of _H and _C should be set on the command line.
dnl When _H is set, _C lines will be thrown away.
dnl Similarly, when _C is set, _H lines will be thrown away.
dnl Stuff that belongs in header files only should be
dnl prefixed with _H, stuff that belongs in .c files only should
dnl be prefixed with _C.
dnl Note that the define()s are in the else part of the ifdef.
dnl Do not make the obvious change without careful thought.
define(`HEADERONLY', `PUSHDIV(-1) $1
POPDIV()')
ifdef(`_H', `define(`HEADERONLY', `$1')', `define(`_H', `dnl')')
define(`SOURCEONLY', `PUSHDIV(-1) $1
POPDIV()')
ifdef(`_C', `define(`SOURCEONLY', `$1')', `define(`_C', `dnl')')


dnl Declare a C pre-processor #define.
dnl CPPDEFINE(name, expansion)
define(`CPPDEFINE', `#define `$1' `$2'')

dnl Declare a C pre-processor #undef.
dnl CPPUNDEF(name)
define(`CPPUNDEF', `#undef `$1'')

dnl CONSTANT(type, name, value)
define(`CONSTANT', `CPPDEFINE(`$2', `$3')')


dnl Function prototypes and implementations
define(`FUNCDIV', ALLOCDIV)
dnl Function prototypes and implementations
define(`INLINEFUNCDIV', ALLOCDIV)

dnl Declare a C function.
dnl Note that this macro also sticks a declaration
dnl in the header file.
dnl FUNCTION(return type and function name, params, body)
define(`FUNCTION', `PUSHDIV(FUNCDIV)dnl
$1($2)HEADERONLY(;)SOURCEONLY(`
{INDENT()dnl
$3}UNINDENT()
')
POPDIV()')

dnl Declare a C function local to the .c file.
dnl The header file is not affected.
dnl STATICFUNCTION(return type and function name, params, body)
define(`STATICFUNCTION', `PUSHDIV(FUNCDIV)SOURCEONLY(
`static $1($2)
{INDENT()dnl
$3}UNINDENT()

')POPDIV()')

dnl Declare a C function which should be compiled inline if possible.
dnl TODO: fallback to a regular function if inline is not supported by
dnl       the compiler.
dnl INLINEFUNCTION(return type and function name, params, body)
define(`INLINEFUNCTION', `PUSHDIV(INLINEFUNCDIV)HEADERONLY(
`static inline $1($2)
{INDENT()dnl
$3}UNINDENT()

')POPDIV()')


dnl Allocate a block or array of storage with a given name.
dnl There is no FREE() macro: just call free().
dnl ALLOC(type, result name, count)
define(`ALLOC', `dnl
TAB()$2 = ($1 *) malloc(($3) * sizeof($1));
TAB()assert($2);')

dnl REALLOC(type, result name, count)
define(`REALLOC', `dnl
TAB()$2 = ($1 *) realloc($2, ($3) * sizeof($1));
TAB()assert($2);')


dnl -- Type macros

dnl TYPEDEF(old name, new name)
define(`TYPEDEF', `PUSHDIV(TYPEDIV)HEADERONLY(`typedef $1 $2;
')POPDIV()')

dnl UNION(name, 1 or more FIELDs)
define(`UNION', `PUSHDIV(-1)
pushdef(`FIELDQTY', 0) pushdef(`PADQTY', 0)
$2
popdef(`PADQTY') popdef(`FIELDQTY')
divert(TYPEDIV)HEADERONLY(`dnl
typedef union $1 {
undivert(STRUCTDIV)dnl
} $1;

')POPDIV()')

dnl CHAR(char-literal)
changequote([,])
define([CHAR],['$1'])
changequote(`,')


dnl -- Diversions used internally

dnl List of parameters in a REQUEST
define(`PARMDIV', ALLOCDIV)
dnl Structure assignment code for binding out->* in REQUEST
define(`ASSNDIV', ALLOCDIV)
dnl Variable-length list construction code in REQUEST
define(`LISTDIV', ALLOCDIV)
dnl Variable declarations for REQUEST bodies
define(`VARDIV', ALLOCDIV)
dnl List of values to check to ensure marshaling is OK in REQUEST
define(`MARSHALDIV', ALLOCDIV)
dnl Holds body of structure declared with STRUCT or UNION macros
define(`STRUCTDIV', ALLOCDIV)
dnl Buffers all structures until end of input
define(`TYPEDIV', ALLOCDIV)

dnl PAD, FIELD, ARRAYFIELD, and POINTERFIELD can be used in either STRUCT or
dnl UNION definitions.
define(`FIELDQTY', 0)
define(`PADQTY', 0)



dnl -- Counters for various internal values

dnl Variable length elements in request
define(`PARTQTY', 0)
dnl Parameters to request (currently tests only for zero/nonzero)
define(`PARAMQTY', 0)


dnl -- Request/Response macros

dnl The *PARAM and *FIELD macros must only appear inside a REQUEST or
dnl VOIDREQUEST macro call, and must be quoted. All fields must appear
dnl in the order the X server expects to recieve them in. Parameters to
dnl the generated request functions will appear in the same order as the
dnl PARAM/FIELD macros they're related to.


dnl The X protocol specification says that the X name of the extension
dnl "should use the ISO Latin-1 encoding, and uppercase and lowercase matter."
dnl The C name should be a valid C identifier which can be guessed easily
dnl from the X name, as it will appear in programmer-visible names.
dnl BEGINEXTENSION(X name, C name)
define(`BEGINEXTENSION', `define(`EXTENSION', `XCB`'$2`'Id')dnl

_H`'extern const char EXTENSION[];
_C`'const char EXTENSION[] = "`$1'";
FUNCTION(`const XCBQueryExtensionRep *XCB`'$2`'Init', `XCBConnection *c', `
    return XCBQueryExtensionCached(c, EXTENSION, 0);
')')

dnl ENDEXTENSION()
define(`ENDEXTENSION', `undefine(`EXTENSION')dnl')


dnl Defines an enumerated protocol type.
dnl XCBENUM(type name, name list)
define(`XCBENUM', `ENUM(XCB`$1', shift($@))')


dnl Defines a BITMASK/LISTofVALUE parameter pair. The bitmask type should
dnl probably be either CARD16 or CARD32, depending on the specified width
dnl of the bitmask. The value array must be given to the generated
dnl function in the order the X server expects.
dnl VALUEPARAM(bitmask type, bitmask name, value array name)
define(`VALUEPARAM', `
PARAM(`$1', `$2')
LISTPARAM(CARD32, `$3', `XCBOnes($2)')
')

dnl Defines a LISTofFOO parameter. The length of the list may be given as
dnl any C expression and may reference any of the other fields of this
dnl request.
dnl LISTPARAM(element type, list name, length expression)
define(`LISTPARAM', `PUSHDIV(PARMDIV), const `$1' *`$2'divert(LISTDIV)
TAB()parts[PARTQTY].iov_base = (caddr_t) `$2';
TAB()parts[PARTQTY].iov_len = (`$3') * sizeof(`$1');
TAB()out->length += (parts[PARTQTY].iov_len + 3) >> 2;
POPDIV()define(`PARTQTY', eval(1+PARTQTY))')

dnl Defines a field which should be filled in with the given expression.
dnl The field name is available for use in the expression of a LISTPARAM
dnl or a following EXPRFIELD.
dnl EXPRFIELD(field type, field name, expression)
define(`EXPRFIELD', `FIELD(`$1', `$2')
PUSHDIV(VARDIV)dnl
TAB()$1 `$2' = `$3';
divert(ASSNDIV)ifdef(`MARSHALABLE', `INDENT()')dnl
TAB()out->`$2' = `$2';
ifdef(`MARSHALABLE', `UNINDENT()')POPDIV()ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Defines a parameter with no associated field. The name can be used in
dnl expressions.
dnl LOCALPARAM(type, name)
define(`LOCALPARAM', `PUSHDIV(PARMDIV), $1 `$2'POPDIV()')

dnl Defines a parameter with a field of the same type.
dnl PARAM(type, name)
define(`PARAM', `FIELD($1, `$2')
PUSHDIV(PARMDIV), $1 `$2'`'dnl
divert(ASSNDIV)ifdef(`MARSHALABLE', `INDENT()')dnl
TAB()out->`$2' = `$2';
ifdef(`MARSHALABLE', `UNINDENT()')POPDIV()define(`PARAMQTY', eval(1+PARAMQTY))
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Sets the major number for all instances of this request to the given code.
dnl OPCODE(number)
define(`OPCODE', `ifdef(`EXTENSION', `
    FIELD(CARD8, `major_opcode')
    FIELD(CARD8, `minor_opcode')
PUSHDIV(VARDIV)dnl
TAB()const XCBQueryExtensionRep *extension = XCBQueryExtensionCached(c, EXTENSION, 0);
TAB()const CARD8 major_opcode = extension->major_opcode;
TAB()const CARD8 minor_opcode = `$1';
divert(ASSNDIV)dnl
dnl TODO: better error handling here, please!
TAB()assert(extension && extension->present);

TAB()out->major_opcode = major_opcode;
TAB()out->minor_opcode = minor_opcode;
POPDIV()
    ifelse(FIELDQTY, 2, `LENGTHFIELD()')
', `
    FIELD(CARD8, `major_opcode')
PUSHDIV(VARDIV)dnl
TAB()const CARD8 major_opcode = `$1';
divert(ASSNDIV)ifdef(`MARSHALABLE', `INDENT()')dnl
TAB()out->major_opcode = major_opcode;
ifdef(`MARSHALABLE', `UNINDENT()')POPDIV()
')')


dnl Form of a request function with marshaling:
dnl if !last || last->major_opcode != major_opcode
dnl    do not marshal
dnl if defined(EXTENSION) && last->minor_opcode != minor_opcode
dnl    do not marshal
dnl foreach i in $@: if last->i != i
dnl    do not marshal
dnl if !marshaling
dnl    out = alloc out buffer
dnl    set all fields in out
dnl else
dnl    out = last
dnl set up parts array, update out->length
dnl write parts
dnl MARSHAL(param name ...)
define(`MARSHAL', `
define(`MARSHALABLE')
ifelse($1, , , `
    PUSHDIV(MARSHALDIV) || out->`$1' != `$1'POPDIV()
    MARSHAL(shift($@))
')
')


dnl REPLY(type, name)
define(`REPLY', `FIELD(`$1', `$2')
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Generates a C pre-processor macro providing access to a variable-length
dnl portion of a structure. The length parameter is an expression, usually
dnl involving the fixed-length portion of the structure, which evaluates
dnl at run-time to the number of elements in this array.
dnl ARRAYFIELD(field type, field name, list length expr)
define(`ARRAYFIELD', `
INLINEFUNCTION(`$1 *'REQ`$2', REQ`'KIND` *R', `
    return (`$1' *) (NEXTFIELD);
')

INLINEFUNCTION(`int 'REQ`$2'Length, REQ`'KIND` *R', `
    return `$3';
')

define(`NEXTFIELD', REQ`$2'`(R) + (`$3')')')

define(`ARRAYREPLY', `ARRAYFIELD($@)')

dnl Generates an iterator for the variable-length portion of a structure.
dnl LISTFIELD(field type, field name, list length expr)
define(`LISTFIELD', `
FUNCTION(`$1Iter 'REQ`$2', REQ`'KIND` *R', `
TAB()$1Iter i;
TAB()i.data = (`$1' *) (NEXTFIELD);
TAB()i.rem = (`$3');
TAB()return i;
')

define(`NEXTFIELD', `$1AfterIter(REQ`$2'((REQ`'KIND *) R))')')


dnl Creates a function named XCB<name> returning XCBVoidCookie and
dnl accepting whatever parameters are necessary to deliver the given PARAMs
dnl and FIELDs to the X server.
dnl VOIDREQUEST(name, 0 or more PARAMs/FIELDs)
define(`VOIDREQUEST', `REQUESTFUNCTION(`Void', `$1', `$2')')

dnl Creates a function named XCB<name> returning XCB<name>Cookie and
dnl accepting whatever parameters are necessary to deliver the given PARAMs
dnl and FIELDs to the X server. Declares the struct XCB<name>Cookie.
dnl Creates a function named XCB<name>Reply returning a pointer to
dnl XCB<name>Rep which forces a cookie returned from XCB<name>, waiting
dnl for the response from the server if necessary. Declares the struct
dnl XCB<name>Rep. The three parameters must be quoted.
dnl REQUEST(name, 0 or more PARAMs, 0 or more REPLYs)
define(`REQUEST',`REQUESTFUNCTION(`$1', `$1', `$2')
_H
pushdef(`NEXTFIELD', `R + 1')dnl
PACKETSTRUCT(`$1', `Rep', `$3')
FUNCTION(`XCB'$1`Rep *XCB'$1`Reply',
`XCBConnection *c, XCB'$1`Cookie cookie, XCBGenericEvent **e', `
    XCBREPTRACER("$1");
    return (XCB`'$1`'Rep *) XCBWaitSeqnum(c, cookie.seqnum, e);
')popdef(`NEXTFIELD')')


dnl Internal function shared by REQUEST and VOIDREQUEST, implementing the
dnl common portions of those macros.
dnl REQUESTFUNCTION(return type, request name, parameters)
define(`REQUESTFUNCTION',`dnl
ifelse($1, Void, `dnl', `COOKIETYPE($1)
_H')
pushdef(`PARTQTY', 0)pushdef(`PARAMQTY', 0)dnl
PACKETSTRUCT(`$2', `Req', `$3')
FUNCTION(`XCB'$1`Cookie XCB'$2, `XCBConnection *c`'undivert(PARMDIV)', `
    XCB`$1'Cookie ret;
    XCB`$2'Req *out;
undivert(VARDIV)`'dnl
ifelse(PARTQTY, 0, `dnl', `    struct iovec parts[PARTQTY];')

    pthread_mutex_lock(&c->locked);
ifdef(`MARSHALABLE', `dnl
    out = (XCB`$2'Req *) c->last_request;
    if(!out || out->major_opcode != major_opcode`'dnl
ifdef(`EXTENSION', ` || out->minor_opcode != minor_opcode')`'dnl
undivert(MARSHALDIV))
    {INDENT()
')dnl
TAB()out = (XCB`$2'Req *) XCBAllocOut(c->handle, XCB_CEIL(sizeof(*out)));
TAB()c->last_request = out;
TAB()XCBREQTRACER("$2");

undivert(ASSNDIV)`'dnl

TAB()ret.seqnum = ++c->seqnum;
ifelse($1, Void, `dnl', `    XCBAddReplyData(c, ret.seqnum);')
ifdef(`MARSHALABLE', `dnl
    }UNINDENT()
    else
    {
        XCBMARSHALTRACER("$2");
dnl XXX: it seems bad to return the same seqnum, but I see no other choice.
        ret.seqnum = c->seqnum;
    }
')dnl
undivert(LISTDIV)`'dnl
ifelse(PARTQTY, 0, `dnl', `    XCBWrite(c->handle, parts, PARTQTY);')
    pthread_mutex_unlock(&c->locked);

    return ret;
')popdef(`PARAMQTY')popdef(`PARTQTY')undefine(`MARSHALABLE')')


dnl Declares a struct holding an XID, and a function to allocate new
dnl instances of this struct.
dnl XIDTYPE(name)
define(`XIDTYPE', `STRUCT(`$1', `FIELD(`CARD32', `xid')')
FUNCTION(`$1 XCB'$1`New', `struct XCBConnection *c', `
    `$1' ret = { XCBGenerateID(c) };
    return ret;
')')


dnl Declares a struct named XCB<name>Cookie with a single "int seqnum"
dnl field.
dnl COOKIETYPE(name)
define(`COOKIETYPE', `dnl
TYPEDEF(`struct XCB`$1'Cookie {
    int seqnum;
}', `XCB`$1'Cookie')')


dnl EVENT(name, number, 1 or more FIELDs)
define(`EVENT', `dnl
_H`'#define XCB`$1' `$2'
PACKETSTRUCT(`$1', `Event', `$3')')

dnl EVENTCOPY(new name, new number, old name)
define(`EVENTCOPY', `HEADERONLY(CPPDEFINE(`XCB'`$1', `$2')
)TYPEDEF(`XCB`$3'Event', `XCB`$1'Event')')

dnl ERROR(name, number, 1 or more FIELDs)
define(`ERROR', `dnl
_H`'#define XCB`$1' `$2'
PACKETSTRUCT(`$1', `Error', `$3')')

dnl ERRORCOPY(new name, new number, old name)
define(`ERRORCOPY', `HEADERONLY(CPPDEFINE(`XCB'`$1', `$2')
)TYPEDEF(`XCB`$3'Error', `XCB`$1'Error')')


dnl EVENTMIDDLE()
define(`EVENTMIDDLE', `FIELD(CARD16, `seqnum')')

dnl ERRORMIDDLE()
define(`ERRORMIDDLE', `FIELD(CARD16, `seqnum')')

dnl REPMIDDLE()
define(`REPMIDDLE', `
    FIELD(CARD16, `seqnum')
    FIELD(CARD32, `length')
')

dnl REQMIDDLE()
define(`REQMIDDLE', `FIELD(CARD16, `length')
PUSHDIV(ASSNDIV)ifdef(`MARSHALABLE', `INDENT()')dnl
TAB()out->length = XCB_CEIL(sizeof(*out)) >> 2;
ifdef(`MARSHALABLE', `UNINDENT()')POPDIV()')

dnl STRUCT(name, 1 or more FIELDs)
define(`STRUCT', `PUSHDIV(-1)
define(`NEXTFIELD', `R + 1')
define(`REQ', $1)
define(`KIND')
$2
divert(TYPEDIV)HEADERONLY(`dnl
typedef struct `$1' {
undivert(STRUCTDIV)dnl
} `$1';

typedef struct `$1'Iter {INDENT()
TAB()`$1' *data;
TAB()int rem;
UNINDENT()} `$1'Iter;

')divert(-1)

FUNCTION(`void `$1'Next', ``$1'Iter *i', `
TAB()$1 *R = i->data;
TAB()--i->rem;
TAB()i->data = ($1 *) (NEXTFIELD());
')

FUNCTION(`void *`$1'AfterIter', ``$1'Iter i', `
TAB()while(i.rem > 0)INDENT()
TAB()`$1'Next(&i);UNINDENT()
TAB()return (void *) i.data;
')

popdef(`LENGTHFIELD')popdef(`REQ')popdef(`KIND')
define(`FIELDQTY', 0)define(`PADQTY', 0)
POPDIV()')

dnl for kind in (Event, Error, Rep, Req)
dnl PACKETSTRUCT(name, kind, 1 or more FIELDs)
define(`PACKETSTRUCT', `PUSHDIV(-1)
pushdef(`REQ', `XCB$1')
pushdef(`KIND', `$2')
pushdef(`LENGTHFIELD', `TOUPPER($2)MIDDLE')
define(`NEXTFIELD', `R + 1')
INDENT()dnl
dnl Everything except requests has a response type.
ifelse(`$2', `Req', , `REPLY(BYTE, `response_type')')
dnl Only errors have an error code.
ifelse(`$2', `Error', `REPLY(BYTE, `error_code')')
$3
dnl Requests and replies always have length fields.
ifelse(FIELDQTY, 1,
    `ifelse(`$2', `Req', `PAD(1)',
    `ifelse(`$2', `Rep', `PAD(1)')')')
UNINDENT()

divert(TYPEDIV)HEADERONLY(`dnl
typedef struct XCB`$1'`$2' {
undivert(STRUCTDIV)dnl
} XCB`$1'`$2';

')divert(-1)

popdef(`LENGTHFIELD')popdef(`REQ')popdef(`KIND')
define(`FIELDQTY', 0)define(`PADQTY', 0)
POPDIV()_H')


dnl -- Other macros

dnl Generates the standard prefix in the output code. The source file name
dnl should not include extension or path.
dnl XCBGEN(source file name, copyright notice)
define(`XCBGEN', `dnl
`/*'
 * This file generated automatically from $1.m4 by macros-xcb.m4 using m4.
 * Edit at your peril.
` */'

HEADERONLY(`dnl
#ifndef __`'TOUPPER($1)_H
#define __`'TOUPPER($1)_H
')SOURCEONLY(`dnl
#include <assert.h>
#include "xcb.h"
#include "xcbint.h"
ifelse($1, `xproto', `', $1, `xcb_types', `', `#include "$1.h"
')dnl
')')

dnl Generates the standard suffix in the output code.
dnl ENDXCBGEN()
define(`ENDXCBGEN', `dnl
undivert(TYPEDIV)dnl
undivert(FUNCDIV)dnl
undivert(INLINEFUNCDIV)dnl
_H`'#endif')

divert(0)`'dnl
