dnl Copyright (C) 2001-2003 Bart Massey and Jamey Sharp.
dnl All Rights Reserved.  See the file COPYING in this directory
dnl for licensing information.
dnl
include(`generics.xcb')dnl
PUSHDIV(-1) dnl Discard any text until a divert(0).

define(`PROTECTCXX', `ifelse(
`$1', `new', `_new',
`$1', `delete', `_delete',
`$1', `class', `_class',
`$1', `operator', `_operator',
``$1'')')

dnl -- Implementations of macros specified in global macros.m4

dnl ENUM(type name, name list)
define(`ENUM', `pushdef(`ENUMNAME', XCB`'EXTENSION`$1')TYPEDEF(`enum {INDENT()
TAB()ENUMNAME`$2'ENUMLOOP(shift(shift($@)))
UNINDENT()}', $1)popdef(`ENUMNAME')')
define(`ENUMLOOP', `ifelse($1, , , `,
TAB()ENUMNAME`$1'ENUMLOOP(shift($@))')')

dnl PAD(bytes)
define(`PAD', `FIELD(`CARD8', `pad'PADQTY`'ifelse($1, 1, , `[$1]'))
define(`PADQTY', eval(1+PADQTY))
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Declares a field of the given type with the given name.
dnl FIELD(type, name)
define(`FIELD', `PUSHDIV(STRUCTDIV)dnl
    `$1' PROTECTCXX(`$2');
POPDIV()define(`FIELDQTY', eval(1+FIELDQTY))')


dnl -- Language-specific macros

dnl Use C-style comments.
changecom(`/*', `*/')

dnl COMMENT(text)
define(`COMMENT', `/* '`$@'` */')


dnl Exactly one of _H and _C should be set on the command line.
dnl When _H is set, _C lines will be thrown away.
dnl Similarly, when _C is set, _H lines will be thrown away.
dnl Stuff that belongs in header files only should be
dnl prefixed with _H, stuff that belongs in .c files only should
dnl be prefixed with _C.
dnl Note that the define()s are in the else part of the ifdef.
dnl Do not make the obvious change without careful thought.
define(`HEADERONLY', `PUSHDIV(-1) $1
POPDIV()')
ifdef(`_H', `define(`HEADERONLY', `$1')', `define(`_H', `dnl')')
define(`SOURCEONLY', `PUSHDIV(-1) $1
POPDIV()')
ifdef(`_C', `define(`SOURCEONLY', `$1')', `define(`_C', `dnl')')



dnl Function prototypes and implementations
define(`FUNCDIV', ALLOCDIV)
dnl Function prototypes and implementations
define(`INLINEFUNCDIV', ALLOCDIV)

dnl Declare a C function.
dnl Note that this macro also sticks a declaration
dnl in the header file.
dnl FUNCTION(return type and function name, params, body)
define(`FUNCTION', `PUSHDIV(FUNCDIV)dnl
$1($2)HEADERONLY(;)SOURCEONLY(`
{INDENT()dnl
$3}UNINDENT()
')
POPDIV()')

dnl Declare a C function local to the .c file.
dnl The header file is not affected.
dnl STATICFUNCTION(return type and function name, params, body)
define(`STATICFUNCTION', `PUSHDIV(FUNCDIV)SOURCEONLY(
`static $1($2)
{INDENT()dnl
$3}UNINDENT()

')POPDIV()')

dnl Declare a C function which should be compiled inline if possible.
dnl TODO: fallback to a regular function if inline is not supported by
dnl       the compiler.
dnl INLINEFUNCTION(return type and function name, params, body)
define(`INLINEFUNCTION', `PUSHDIV(INLINEFUNCDIV)HEADERONLY(
`static inline $1($2)
{INDENT()dnl
$3}UNINDENT()

')POPDIV()')


dnl -- Type macros

dnl TYPEDEF(old name, new name)
define(`TYPEDEF', `define(`$2', `XCB'EXTENSION`$2')dnl
PUSHDIV(TYPEDIV)HEADERONLY(`typedef $1 $2;

')POPDIV()')

dnl NEXTFIELD must be defined, and must evaluate to the address of the
dnl byte following an instance of $1. When NEXTFIELD is evaluated, a
dnl variable named R of type `pointer to $1' points to the current
dnl instance of $1.
dnl
dnl NEXTFIELD must string-match `R + 1' to generate efficient code for
dnl iterating over fixed-length fields.
dnl
dnl ITERATOR(base type name)
define(`ITERATOR', `
TYPEDEF(`struct {INDENT()
TAB()$1 *data;
TAB()int rem;
TAB()int index;
UNINDENT()}', `$1Iter')

ifelse(NEXTFIELD, `R + 1',
`dnl Iterate over a fixed-length object.
FUNCTION(`void XCB'EXTENSION`$1Next', $1Iter `*i', `
TAB()--i->rem;
TAB()++i->data;
TAB()i->index += sizeof($1);
')

FUNCTION(`XCBGenericIter XCB'EXTENSION`$1End', $1Iter `i', `
TAB()XCBGenericIter ret;
TAB()ret.data = i.data + i.rem;
TAB()ret.index = i.index + ((char *) ret.data - (char *) i.data);
TAB()ret.rem = 0;
TAB()return ret;
')
',
`dnl Iterate over a variable-length object.
FUNCTION(`void XCB'EXTENSION`$1Next', $1Iter `*i', `
TAB()$1 *R = i->data;
TAB()XCBGenericIter child = NEXTFIELD();
TAB()--i->rem;
TAB()i->data = ($1 *) child.data;
TAB()i->index = child.index;
')

FUNCTION(`XCBGenericIter XCB'EXTENSION`$1End', $1Iter `i', `
TAB()XCBGenericIter ret;
TAB()while(i.rem > 0)INDENT()
TAB()$1`'Next(&i);UNINDENT()
TAB()ret.data = i.data;
TAB()ret.rem = i.rem;
TAB()ret.index = i.index;
TAB()return ret;
')
')
')

define(`COMPOUND',
`PUSHDIV(-1)
define(`NEXTFIELD', `R + 1')
pushdef(`LENGTHFIELD')pushdef(`REQ', XCB`'EXTENSION`'$1)pushdef(`KIND')
$2
TYPEDEF(``$3' {
undivert(STRUCTDIV)dnl
}', `$1')
ifelse(`$3', `union', `
dnl UNIONs must be fixed length.
ifelse(NEXTFIELD, `R + 1', , `errprint(__file__:__line__: Illegal variable-length UNION `$1'.
)')')
ITERATOR(`$1')
popdef(`LENGTHFIELD')popdef(`REQ')popdef(`KIND')
define(`FIELDQTY', 0)define(`PADQTY', 0)
POPDIV()')

dnl UNION(name, 1 or more FIELDs)
define(`UNION', `COMPOUND($@, `union')')

dnl STRUCT(name, 1 or more FIELDs)
define(`STRUCT', `COMPOUND($@, `struct')')


dnl -- Diversions used internally

dnl List of parameters in a REQUEST
define(`PARMDIV', ALLOCDIV)
dnl Structure assignment code for binding out.* in REQUEST
define(`ASSNDIV', ALLOCDIV)
dnl Variable-length list construction code in REQUEST
define(`LISTDIV', ALLOCDIV)
dnl Variable declarations for REQUEST bodies
define(`VARDIV', ALLOCDIV)
dnl List of values to check to ensure marshaling is OK in REQUEST
define(`MARSHALDIV', ALLOCDIV)
dnl Holds body of structure declared with STRUCT or UNION macros
define(`STRUCTDIV', ALLOCDIV)
dnl Buffers all structures until end of input
define(`TYPEDIV', ALLOCDIV)

dnl PAD, FIELD, and ARRAYFIELD can be used in either STRUCT or
dnl UNION definitions.
define(`FIELDQTY', 0)
define(`PADQTY', 0)



dnl -- Counters for various internal values

dnl Variable length elements in request
define(`PARTQTY', 0)
dnl Parameters to request (currently tests only for zero/nonzero)
define(`PARAMQTY', 0)


dnl -- Request/Response macros

dnl The *PARAM and *FIELD macros must only appear inside a REQUEST or
dnl VOIDREQUEST macro call, and must be quoted. All fields must appear
dnl in the order the X server expects to recieve them in. Parameters to
dnl the generated request functions will appear in the same order as the
dnl PARAM/FIELD macros they're related to.

dnl By default, all generated code is part of the core protocol.
define(`EXTENSION', `')

dnl The X protocol specification says that the X name of the extension
dnl "should use the ISO Latin-1 encoding, and uppercase and lowercase matter."
dnl The C name should be a valid C identifier which can be guessed easily
dnl from the X name, as it will appear in programmer-visible names.
dnl BEGINEXTENSION(X name, C name)
define(`BEGINEXTENSION', `define(`EXTENSION', `$2')dnl

_H`'extern const char XCB`'EXTENSION`'Id[];
_C`'const char XCB`'EXTENSION`'Id[] = "`$1'";
FUNCTION(`const XCBQueryExtensionRep *XCB`'EXTENSION`'Init', `XCBConnection *c', `
    return XCBQueryExtensionCached(c, XCB`'EXTENSION`'Id, 0);
')')

dnl ENDEXTENSION()
define(`ENDEXTENSION', `define(`EXTENSION', `')dnl')


dnl Defines a BITMASK/LISTofVALUE parameter pair. The bitmask type should
dnl probably be either CARD16 or CARD32, depending on the specified width
dnl of the bitmask. The value array must be given to the generated
dnl function in the order the X server expects.
dnl VALUEPARAM(bitmask type, bitmask name, value array name)
define(`VALUEPARAM', `
PARAM(`$1', `$2')
LISTPARAM(CARD32, `$3', `XCBOnes($2)')
')

dnl Defines a LISTofFOO parameter. The length of the list may be given as
dnl any C expression and may reference any of the other fields of this
dnl request.
dnl LISTPARAM(element type, list name, length expression)
define(`LISTPARAM', `PUSHDIV(PARMDIV), const `$1' *`$2'divert(LISTDIV)dnl
TAB()parts[PARTQTY].iov_base = (void *) `$2';
TAB()parts[PARTQTY].iov_len = (`$3')ifelse(`$1', void, , ` * sizeof(`$1')');
POPDIV()define(`PARTQTY', eval(1+PARTQTY))')

dnl Defines a field which should be filled in with the given expression.
dnl The field name is available for use in the expression of a LISTPARAM
dnl or a following EXPRFIELD.
dnl EXPRFIELD(field type, field name, expression)
define(`EXPRFIELD', `FIELD(`$1', `$2')
PUSHDIV(VARDIV)dnl
TAB()$1 `$2' = `$3';
divert(ASSNDIV)dnl
TAB()out.PROTECTCXX(`$2') = `$2';
POPDIV()ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Defines a parameter with no associated field. The name can be used in
dnl expressions.
dnl LOCALPARAM(type, name)
define(`LOCALPARAM', `PUSHDIV(PARMDIV), $1 `$2'POPDIV()')

dnl Defines a parameter with a field of the same type.
dnl PARAM(type, name)
define(`PARAM', `FIELD($1, `$2')
PUSHDIV(PARMDIV), $1 PROTECTCXX(`$2')`'dnl
divert(ASSNDIV)dnl
TAB()out.PROTECTCXX(`$2') = PROTECTCXX(`$2');
POPDIV()define(`PARAMQTY', eval(1+PARAMQTY))
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Sets the major number for all instances of this request to the given code.
dnl OPCODE(number)
define(`OPCODE', `ifelse(EXTENSION, , `
    FIELD(CARD8, `major_opcode')
PUSHDIV(VARDIV)dnl
TAB()const CARD8 major_opcode = `$1';
divert(ASSNDIV)dnl
TAB()out.major_opcode = major_opcode;
POPDIV()
', `
    FIELD(CARD8, `major_opcode')
    FIELD(CARD8, `minor_opcode')
PUSHDIV(VARDIV)dnl
TAB()const XCBQueryExtensionRep *extension = XCB`'EXTENSION`'Init(c);
TAB()const CARD8 major_opcode = extension->major_opcode;
TAB()const CARD8 minor_opcode = `$1';
divert(ASSNDIV)dnl
dnl TODO: better error handling here, please!
TAB()assert(extension && extension->present);

TAB()out.major_opcode = major_opcode;
TAB()out.minor_opcode = minor_opcode;
POPDIV()
    ifelse(FIELDQTY, 2, `LENGTHFIELD()')
')')


dnl Declare that this request is permitted to be marshaled.
dnl MARSHAL()
define(`MARSHAL', `define(`MARSHALABLE')')


dnl REPLY(type, name)
define(`REPLY', `FIELD(`$1', `$2')
ifelse(FIELDQTY, 2, `LENGTHFIELD()')')

dnl Generates a C pre-processor macro providing access to a variable-length
dnl portion of a structure. The length parameter is an expression, usually
dnl involving the fixed-length portion of the structure, which evaluates
dnl at run-time to the number of elements in this array.
dnl ARRAYFIELD(field type, field name, list length expr)
define(`ARRAYFIELD', `
pushdef(`NAME', `JOIN(`', MAP(`UCFIRST', SPLIT(`_', `$2')))')
FUNCTION(`$1 *'REQ`'NAME, REQ`'KIND` *R', `
ifelse(NEXTFIELD, `R + 1', `dnl
    return (`$1' *) (NEXTFIELD);', `dnl
    XCBGenericIter prev = NEXTFIELD();
    return (`$1' *) ((char *) prev.data + XCB_TYPE_PAD(`$1', prev.index));')
')

FUNCTION(`int 'REQ`'NAME`'Length, REQ`'KIND` *R', `
    return `$3';
')

FUNCTION(`XCBGenericIter' REQ`'NAME`'End, REQ`'KIND` *R', `
    XCBGenericIter i;
ifelse(NEXTFIELD, `R + 1', `dnl
    i.data = ((ifelse(`$1', void, char, `$1') *) (NEXTFIELD())) + (`$3');', `dnl
    XCBGenericIter child = NEXTFIELD();
    i.data = ((ifelse(`$1', void, char, `$1') *) child.data) + (`$3');')
    i.rem = 0;
    i.index = (char *) i.data - (char *) R;
    return i;
')

define(`NEXTFIELD', REQ`'NAME`End'(R))
popdef(`NAME')
')

define(`ARRAYREPLY', `ARRAYFIELD($@)')

dnl Generates an iterator for the variable-length portion of a structure.
dnl LISTFIELD(field type, field name, list length expr)
define(`LISTFIELD', `
pushdef(`NAME', `JOIN(`', MAP(`UCFIRST', SPLIT(`_', `$2')))')
FUNCTION(`$1Iter 'REQ`'NAME, REQ`'KIND` *R', `
TAB()$1Iter i;
ifelse(NEXTFIELD, `R + 1', `dnl
TAB()i.data = (`$1' *) (NEXTFIELD());', `dnl
TAB()XCBGenericIter prev = NEXTFIELD();
TAB()i.data = (`$1' *) ((char *) prev.data + XCB_TYPE_PAD(`$1', prev.index));')
TAB()i.rem = (`$3');
TAB()i.index = (char *) i.data - (char *) R;
TAB()return i;
')

define(`NEXTFIELD', `$1End'(REQ`'NAME`'(R)))
popdef(`NAME')
')


dnl Creates a function named XCB<name> returning XCBVoidCookie and
dnl accepting whatever parameters are necessary to deliver the given PARAMs
dnl and FIELDs to the X server.
dnl VOIDREQUEST(name, 0 or more PARAMs/FIELDs)
define(`VOIDREQUEST', `REQUESTFUNCTION(`Void', `$1', `$2')')

dnl Creates a function named XCB<name> returning XCB<name>Cookie and
dnl accepting whatever parameters are necessary to deliver the given PARAMs
dnl and FIELDs to the X server. Declares the struct XCB<name>Cookie.
dnl Creates a function named XCB<name>Reply returning a pointer to
dnl XCB<name>Rep which forces a cookie returned from XCB<name>, waiting
dnl for the response from the server if necessary. Declares the struct
dnl XCB<name>Rep. The three parameters must be quoted.
dnl REQUEST(name, 0 or more PARAMs, 0 or more REPLYs)
define(`REQUEST',`REQUESTFUNCTION(`$1', `$1', `$2')
_H
pushdef(`NEXTFIELD', `R + 1')dnl
PACKETSTRUCT(`$1', `Rep', `$3')
FUNCTION($1Rep `*XCB'EXTENSION`$1Reply',
`XCBConnection *c,' $1Cookie `cookie, XCBGenericError **e', `
    return (XCB`'EXTENSION`'$1`'Rep *) XCBWaitReply(c, cookie.sequence, e);
')popdef(`NEXTFIELD')')


dnl Internal function shared by REQUEST and VOIDREQUEST, implementing the
dnl common portions of those macros.
dnl REQUESTFUNCTION(return type, request name, parameters)
define(`REQUESTFUNCTION',`dnl
ifelse($1, Void, `dnl', `COOKIETYPE($1)
_H')
pushdef(`PARTQTY', 1)pushdef(`PARAMQTY', 0)dnl
PACKETSTRUCT(`$2', `Req', `$3')
FUNCTION($1Cookie `XCB'EXTENSION`$2', `XCBConnection *c`'undivert(PARMDIV)', `
    struct iovec parts[PARTQTY];
    $1Cookie ret;
    $2Req out;
undivert(VARDIV)`'dnl

undivert(ASSNDIV)`'dnl

    parts[0].iov_base = &out;
    parts[0].iov_len = sizeof(out);
undivert(LISTDIV)`'dnl
    XCBSendRequest(c, &ret.sequence, /* isvoid */ ifelse($1, Void, 1, 0), parts, /* partqty */ PARTQTY);
    return ret;
')popdef(`PARAMQTY')popdef(`PARTQTY')undefine(`MARSHALABLE')')


dnl Declares a struct holding an XID, and a function to allocate new
dnl instances of this struct.
dnl XIDTYPE(name)
define(`XIDTYPE', `STRUCT(`$1', `FIELD(`CARD32', `xid')')
FUNCTION($1 $1`New', `XCBConnection *c', `
    $1 ret;
    ret.xid = XCBGenerateID(c);
    return ret;
')')


dnl Declares a struct named XCB<name>Cookie with a single "int sequence"
dnl field.
dnl COOKIETYPE(name)
define(`COOKIETYPE', `dnl
TYPEDEF(`struct {
    unsigned int sequence;
}', `$1Cookie')')


dnl EVENT(name, number, 1 or more FIELDs)
define(`EVENT', `dnl
PUSHDIV(TYPEDIV)HEADERONLY(`#define XCB`'EXTENSION`$1' `$2'
')POPDIV()
PACKETSTRUCT(`$1', `Event', `$3')')

dnl EVENTCOPY(new name, new number, old name)
define(`EVENTCOPY', `dnl
PUSHDIV(TYPEDIV)HEADERONLY(`#define XCB`'EXTENSION`$1' `$2'
')POPDIV()
TYPEDEF($3Event, $1Event)')

dnl ERROR(name, number, 1 or more FIELDs)
define(`ERROR', `dnl
PUSHDIV(TYPEDIV)HEADERONLY(`#define XCB`'EXTENSION`$1' `$2'
')POPDIV()
PACKETSTRUCT(`$1', `Error', `$3')')

dnl ERRORCOPY(new name, new number, old name)
define(`ERRORCOPY', `dnl
PUSHDIV(TYPEDIV)HEADERONLY(`#define XCB`'EXTENSION`$1' `$2'
')POPDIV()
TYPEDEF($3Error, $1Error)')


dnl EVENTMIDDLE()
define(`EVENTMIDDLE', `FIELD(CARD16, `sequence')')

dnl ERRORMIDDLE()
define(`ERRORMIDDLE', `FIELD(CARD16, `sequence')')

dnl REPMIDDLE()
define(`REPMIDDLE', `
    FIELD(CARD16, `sequence')
    FIELD(CARD32, `length')
')

dnl REQMIDDLE()
define(`REQMIDDLE', `FIELD(CARD16, `length')')

dnl for kind in (Event, Error, Rep, Req)
dnl PACKETSTRUCT(name, kind, 1 or more FIELDs)
define(`PACKETSTRUCT', `PUSHDIV(-1)
pushdef(`REQ', `XCB'EXTENSION`$1')
pushdef(`KIND', `$2')
pushdef(`LENGTHFIELD', `TOUPPER($2)MIDDLE')
define(`NEXTFIELD', `R + 1')
INDENT()dnl
dnl Everything except requests has a response type.
ifelse(`$2', `Req', , `REPLY(BYTE, `response_type')')
dnl Only errors have an error code.
ifelse(`$2', `Error', `REPLY(BYTE, `error_code')')
$3
dnl Requests and replies always have length fields.
ifelse(FIELDQTY, 1,
    `ifelse(`$2', `Req', `PAD(1)',
    `ifelse(`$2', `Rep', `PAD(1)')')')
UNINDENT()

divert(-1)
TYPEDEF(`struct {
undivert(STRUCTDIV)dnl
}', `$1$2')

popdef(`LENGTHFIELD')popdef(`REQ')popdef(`KIND')
define(`FIELDQTY', 0)define(`PADQTY', 0)
POPDIV()_H')


dnl -- Other macros

dnl Generates the standard prefix in the output code. The source file name
dnl should not include extension or path.
dnl XCBGEN(source file name, copyright notice)
define(`XCBGEN', `dnl
`/*'
 * This file generated automatically from $1.m4 by macros-xcb.m4 using m4.
 * Edit at your peril.
` */'

HEADERONLY(`dnl
#ifndef __`'TOUPPER($1)_H
#define __`'TOUPPER($1)_H
')SOURCEONLY(`dnl
#include <assert.h>
#include "xcb.h"
ifelse($1, `xcb_types', `', $1, `xproto', `', `#include "$1.h"
')dnl
')PUSHDIV(-1)
ifelse($1, `xcb_types', `', $1, `xproto', `include(`xcb_types.xcb')', `include(`xproto.xcb')')
define(`VoidCookie', `XCBVoidCookie')
POPDIV()dnl
')

dnl Generates the standard suffix in the output code.
dnl ENDXCBGEN()
define(`ENDXCBGEN', `dnl
undivert(TYPEDIV)dnl
undivert(FUNCDIV)dnl
undivert(INLINEFUNCDIV)dnl
_H`'#endif')

POPDIV()`'dnl
