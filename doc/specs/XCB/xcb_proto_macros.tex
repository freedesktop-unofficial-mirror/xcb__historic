\documentclass{article}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}

\begin{document}

\title{XCB Protocol Implementation Macro Language}


\author{Jamey Sharp}

\maketitle

\section{Terminology}

In this document, terms shall be used as follows.

A ``field'' is a unit of information in a real protocol request. Fields
are never visible to programmers using XCB.

A ``reply field'' is a unit of information in a real protocol reply.
Reply fields are directly visible to programmers using XCB.

A ``param'' (``parameter'') is a unit of information passed to a protocol
request wrapper function. It may or may not correspond to a field.


\section{Requests and Replies}


\subsection{Extension Support: BEGINEXTENSION and ENDEXTENSION}

BEGINEXTENSION(X name, C name)\\
ENDEXTENSION

An extension's X name is the string used to identify it to the server
(e.g. `DPMS', `SHAPE', `XVideo'). The X protocol specification says that
the X name of the extension ``should use the ISO Latin-1 encoding, and
uppercase and lowercase matter.''

An extension's C name should be a valid C identifier which can be guessed
easily from the X name: it will appear in some names visible to
programmers using XCB.


\subsection{VOIDREQUEST}

VOIDREQUEST(name, 0 or more PARAMs/FIELDs)

Creates a function named XCB\_<name> returning XCB\_void\_cookie and
accepting whatever parameters are necessary to deliver the given PARAMs
and FIELDs to the X server. Requests created with this macro do not
expect a reply.


\subsection{REQUEST}

REQUEST(name, 0 or more PARAMs, 0 or more REPLYs)

Creates a function named XCB\_<name> whose return result is
an XCB\_<name>\_cookie and whose parameters are whatever is
necessary to deliver the given PARAMs and FIELDs to the X
server. Declares the struct XCB\_<name>\_cookie.  Creates a
function named XCB\_<name>\_Reply returning a pointer to
XCB\_<name>\_Rep which forces a cookie returned from
XCB\_<name>, waiting for the response from the server if
necessary. If any REPLYs are given, they must be quoted.


\subsection{Request Parameters and Fields}

These PARAM and FIELD macros may only appear within the second
parameter to the REQUEST or VOIDREQUEST macros, and must always
be quoted.

All of these macro calls must appear in the order specified
by Appendix B (Protocol Encoding) of the X Window System Protocol
specification, or the equivalent documentation for any extension.
However, LISTs (including LISTofVALUEs) are always grouped after
any fixed-length section.

Information about padding bytes must be known, so you may need to
specify it using the PAD macro. However, in several cases this
information can be inferred by the macros and thus can be omitted:
  \begin{itemize}
  \item After the last fixed-length field in a fixed-length request or reply.
  \item After the last fixed-length field in a variable-length request.
  \item Between each variable-length field and the next 4-byte aligned boundary in a request.
  \end{itemize}


\subsubsection{OPCODE}

OPCODE(number)

For extensions, this macro generates code to look up the major number
and sets the minor number to the given value.

For the core protocol, this macro sets the major number to the given
value.


\subsubsection{PAD}

PAD(bytes)

Inserts the given number of padding bytes.


\subsubsection{PARAM}

PARAM(type, name)

Defines a parameter with a field of the same type.


\subsubsection{VALUEPARAM}

VALUEPARAM(bitmask type, bitmask name, value array name)

Defines a BITMASK/LISTofVALUE parameter pair. The bitmask type should
probably be either CARD16 or CARD32, depending on the specified width
of the bitmask. The value array must be given to the generated function
in the order the X server expects.

Caution! No type-, value-, or bounds-checking is done on this array by
XCB. The X server and your operating system may not catch errors either,
leading to odd results if you're not careful.


\subsubsection{LISTPARAM}

LISTPARAM(element type, list name, length expression)

Defines a LISTofFOO parameter. The length of the list may be given
as any C expression and may reference any of the other fields of this
request.


\subsubsection{LOCALPARAM}

LOCALPARAM(type, name)

Defines a parameter with no associated field. The name can be used
in expressions.

This macro can be useful in conjunction with LISTs where you need to
pass the number of items to the LISTPARAM macro, but in the protocol
the list length is implicit in the request length.


\subsubsection{EXPRFIELD}

EXPRFIELD(field name, expression)

Defines a field which should be filled in with the given expression.
The field has no associated parameter. The name can be used in
expressions.

This macro can be useful when the protocol requires an explicit
field containing a value which is easily calculated from the
information available.

The recommended idiom for strings which aren't expected to contain
null characters combines EXPRFIELD with LISTPARAM. This allows
programmers familiar with C to work with XCB naturally.

\begin{figure}
\begin{quote}\begin{verbatim}
EXPRFIELD(CARD16, `name_len', `strlen(name)')
LISTPARAM(char, `name', `name_len')
\end{verbatim}\end{quote}
\caption{Example macro usage for C-style strings.}\label{fig-string}
\end{figure}


\subsection{ARRAYREPLY}

ARRAYREPLY(field type, field name, length name)

Generates a C pre-processor macro providing access to a variable-length
portion of a reply. The length name should be provided. The length name
is the name of a field in the fixed-length portion of the response which
contains the number of elements in this section.

This macro provides full random access to any portion of the
variable-length portion of a reply, but it's only suitable for LISTs of
fixed-length elements.


\section{Utility Macros}


\subsection{Header File Generation}


\subsubsection{\_H and \_C}

For code which should appear only in a header (.h) file or only in
an implementation (.c) file, lines may be prefixed with the \_H and
\_C macros, respectively.


\subsubsection{XCBGEN and ENDXCBGEN}

XCBGEN(header name)\\
ENDXCBGEN()

The first line (aside from comments) of any XCB protocol implementation
should contain a call to the XCBGEN macro, and the last line should
contain a call to the ENDXCBGEN macro. The header name should generally
be the base name of the source file, with all lowercase letters capitalized,
and all other characters converted to underscores ({}``\_''): for
example, xcb\_conn.m4 uses XCB\_CONN here.

XCBGEN automatically causes the header file to be \#included by the
implementation file.


\subsection{Indentation}


\subsubsection{INDENT}

INDENT()

Move line indentation to the right 4 spaces.


\subsubsection{UNINDENT}

UNINDENT()

Move line indentation to the left 4 spaces.


\subsubsection{TAB}

TAB()

Indent current line appropriately by inserting spaces.


\subsection{Functions}


\subsubsection{FUNCTION}

FUNCTION(return type and function name, params, body)

Declares a C function, placing the appropriate prototype in the header
file and the complete function in the implementation file.


\subsubsection{STATICFUNCTION}

STATICFUNCTION(return type and function name, params, body)

Declares a static-scope C function. No prototype is placed in the
header file, and the keyword static is applied to the function in
the implementation file.


\subsubsection{INLINEFUNCTION}

INLINEFUNCTION(return type and function name, params, body)

Declare a C function which should be compiled inline if possible.
The function is placed in the header file and declared ``static inline''.

A future implementation of these macros should fall back to
generating a regular function if inlines aren't supported by the
compiler, but this isn't implemented yet.


\subsection{Memory Allocation}

Note that there is no FREE macro; just call free().


\subsubsection{ALLOC}

ALLOC(type, result name, count)

Allocate a block or array of storage with a given name.


\subsubsection{REALLOC}

REALLOC(type, result name, count)

Reallocate a previously-allocated block or array of storage with a
given name, resizing it for the new count.


\subsection{Diversions}


\subsubsection{PUSHDIV}

PUSHDIV(diversion)

Pushes the given diversion onto the diversion stack, switching to
it in the process.


\subsubsection{POPDIV}

POPDIV()

Pops the current diversion off the diversion stack, returning to the
diversion which was in effect before the last PUSHDIV.


\section{Structures and Unions}


\subsection{STRUCT}

STRUCT(name, 1 or more FIELDs)

Typedefs a structure defined to contain the given fields so that it
has the given name.


\subsection{UNION}

UNION(name, 1 or more FIELDs)

Typedefs a union defined to contain the given fields so that it has
the given name.


\subsection{Field Declarations}

These declarations may be used in either STRUCT or UNION definitions.


\subsubsection{FIELD}

FIELD(type, name)

Declares a field of the given type with the given name.


\subsubsection{ARRAYFIELD}

ARRAYFIELD(type, name, quantity)

Declares an array field with the given quantity of elements of the
given type.


\subsubsection{POINTERFIELD}

POINTERFIELD(type, name)

Declares a field with the given name which is a pointer to the given
type.
\end{document}
